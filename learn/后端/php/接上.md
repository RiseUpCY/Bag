# 那边的没推

## 模型

### 1.访问器与修改器

``` php
// 在模型中定义方法getDisplayNameAttribute，就能直接通过display_name属性访问
public function getDisplayNameAttribute()
{
    return $this->nickname ? $this->nickname : $this->name;
}
$user->display_name

// 放入数据库前会先修改属性，setCardNoAttribute，会将传入card_no修改
public function setCardNoAttribute($value)
{
    $value = str_replace(' ', '', $value);  // 将所有空格去掉
    $this->attributes['card_no'] = encrypt($value);
}
$user->card_no = '6222020903001483077';

// 数组 & JSON 转化，直接存取即可
$user->settings = ['city' => '杭州', 'hobby' => ['读书','撸码']];
$user->save();

```

### 2. 作用域

``` php
// 使用全局作用域后，之后的操作都会带上相应的操作whereNotNull
// app/Scopes 目录下
<?php
namespace App\Scopes;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;

class EmailVerifiedAtScope implements Scope
{
    public function apply(Builder $builder, Model $model)
    {
        return $builder->whereNotNull('email_verified_at');
    }
}
// 模型类里使用
protected static function boot()
{
    parent::boot();

    static::addGlobalScope(new EmailVerifiedAtScope());
}
// 移除全局作用域
User::withoutGlobalScope('email_verified_at_scope')->get();


// 局部作用域
// 模型类中编写，scopePopular 对应 popular
public function scopePopular(Builder $query)
{
    return $query->where('views', '>', '0')->orderBy('views', 'desc');
}
$post = Post::popular()->get();

// 动态作用域， 可以传如想要的type
public function scopeOfType(Builder $query, $type)
{
    return $query->where('type', $type);
}
$posts = Post::active()->ofType(Post::Article)->get();
```

### 3. 模型事件和监听方式

### 4. 关联关系,连表查询

``` php
// hasOne 关联另一个表模型， select * from userprofile
// public function hasOne($related, $foreignKey = null, $localKey = null)，
// params： 关联的表， 关联表用于连接的key，本表用于连接的key
public function profile()
{
    return $this->hasOne(UserProfile::class);
}
// 反查所属模型，belongsTo
// public function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null)
// params：关联的表，本表用于连接的key，关联表用于连接的key， 对应关联关系方法名
public function profile()
{
    return $this->belongsTo(UserProfile::class);
}

// 一对多 hasMany ，参数同上
public function posts()
{
    return $this->hasMany(Post::class);
}
// 多对多 belongsToMany， 通过本表的key找到中间表，然后中间表的关联key找到对应的关联表
// public function belongsToMany($related, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $relation = null)
// params：关联表类，中间表名，中间表的查询key，中间表对应关联表的key， 本表的key，关联表的key
```

### 5. 渴求式加载

``` php
// 先在模型里关联author
$posts = Post::with('author')
    ->where('views', '>', 0)
    ->offset(1)->limit(10)
    ->get();
```
